---
title: "Tutorial"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
    collapsed: false
    css: style.css
---

<br>


# Learning R fundamentals

<br>



## <font color="red">Basic operators and datatypes</font>

<br>

### <font color="red">Arithmetic operators</font> 

Arithmetic operators in R works as the normal mathematic operators and follow the order of operations/calculations.  

```{r}
20 * 4 + 1
```

Just as in mathematics operations, parentheses `()` can be used to change the order of operations.

```{r}
20 * (4 + 1)
```

<br>

>More arithmetic operators:

```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
library(knitr)
mathematics <- c("a + b", "a - b", "a $\\times$ b", "a $\\div$ b", "a $\\%$ b", "$a ^ b$")
arithmetic <- c("a + b", "a - b", "a * b", "a / b", "a %% b", "a ^ b")
descriptions <- c("a plus b", "a minus b", "a multiply b", "a divided by b", "remainder of a divided by b", "a raised to the bth power")
df <- data.frame(mathematics, arithmetic, descriptions)
colnames(df) <- c("Mathematics operators", "R arithmetic operators", "Descriptions")
x_html <- kable(df, escape = F, "html")
kableExtra::kable_styling(
  x_html,
  protect_latex = TRUE
)
```

----

Way more than a calculator, R can not only operate on numerical values, but also on `vectors`, an important data type in R. Vectorization makes R very efficient in operating with high dimensional data.



You can define a vector as below:

```{r}
c(1, 2, 3)
```

Operate on vectors:

```{r}
c(2, 4, 3)
c(2, 4, 3) / 2
c(2, 4, 3) + c(1, 2, 3)
c(2, 4, 3) / 2 + c(1, 2, 3) * 3
```

<style>
div.Tip1, div.Tip2, div.Tip3 {
  padding: 1em;
  margin: 1em 0;
  padding-left: 100px;
  background-size: 70px;
  background-repeat: no-repeat;
  background-position: 15px center;
  min-height: 120px;
  color: #1f5386;
  background-color: #bed3ec;
  border: solid 5px #dfedff;
  background-image: url("images/lightbulb.png")
}
</style>


<div class = "Tip1">

**NOTE**

Some frequently used R-objects are: "Vectors", "Lists", "Matrices", "Arrays", "Factors", and "Dataframes". 

"Vectors" which we just worked with is probably the simplest and most fundamental object. Vectors can be of six classes: Logical (e.g., TRUE, FALSE), Numeric (e.g., 20.34, 100), Integer (e.g., 0L, 3L), Complex (e.g., 3+2i), Character (e.g., 'Hello world', '3.14', 'z'), and Raw (e.g., `charToRaw("math")`). 

Later we will also go through dataframes in this workshop.

</div>






No matter which R object we are working with, sometimes it may not be easy to directly embed these data into a math operation or other functions as above (e.g., what if the data is a $1000 \times 10000$ matrix). Instead we will assign and store the data / value to a so-called "variable".

<br>

### <font color="red">Assignment operators</font> 

We can assign value to variable with assignment operator `<-`. Let's assign `c(2, 4, 3)` to variable `x`:

```{r}
x <- c(2, 4, 3)
x
```

```{r}
x / 2
y <- x / 2
y
```


Shortcut for assignment operator:

- In Windows: `Alt` + `-`   
- In Mac: `Cmd` + `-`

<br>

### <font color="red">Exercise</font>

- Assign `c(15, 256, 11)` to variable `num`   
- Check if each number in `num` is odd    

<br>


## <font color="orange">Functions and Packages</font> 

<br>

**1. Functions**

The base R has many useful built-in functions that maybe helpful to your data. The normal syntax of using a function is as such: `function_name(argument 1, argument 2, ...)` 

- `print` can be used to display information

```{r}
y
print(y)
```

- `sort`: Order a vector into ascending or descending order.

```{r}
# function name: sort; argument: y
sort(y)
```

We just sorted a vector in ascending order, but how to do it in descending order? **How to get all the arguments info of a function and learn how to use a function?**

- Normally, you can find the detailed description, usage, and arguments information in the function/package R documentation. Search the R Documentation by `?function_name` or search R help files with a word or phrase by `??regresion`:

```{r}
?sort

# sort vector y in descending order
sort(y, decreasing = TRUE)

??regresion
```

- The second way is just to Google!

<br>

**2. Packages**

There are many basic and useful functions in base R. Sometimes the functions you want to use may not be included in base R, but instead in a specific R package. That's when we need to install the package. 

`dplyr` is a R package that we will use for data manipulation later in this workshop.

```{r, eval=FALSE}
# install the package
install.packages("dplyr")

# load and attach add-on packages
library(dplyr)
```


<div class = "Tip2">

**NOTE**

Most of the times, you can find help about the function/package that you are interested in from its documentation or online sources. But if your work needs some specific functions or the same chunk of code is reused multiple times, it's always a good idea to write your own functions or even packages! See these resources of [creating functions](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/) and 
[your own R package](http://web.mit.edu/insong/www/pdf/rpackage_instructions.pdf).

</div>




<br>

### <font color="orange">Exercise</font>

- `ggplot2` is a package that makes graphics with user input data and commands. Install and load `ggplot2`. 

<br>



# Data exploring with R

<br>

## <font color="darkgoldenrod">Accessing elements in dataframes</font> 

<br>

**1. Accessing elements in a vector use `[index]` or `[index_start : index_end]`**

```{r}
z <- c(y, 200)
z
# access the third element in z
z[3]
# access the second to forth elements in z
z[2:4]
```

----

<br>

**2. Import data to R**

In practice, we may often work with a dataframe that looks like this:

```{r echo=FALSE, results='asis'}
library(kableExtra)
kable(mtcars[1:5, ]) %>% 
  kable_styling()
```

Before talking about how to access values in such dataframes, let's first see how we can import a dataset into R:

```{r}
?read.table()
ghg <- read.table("/Users/liujia/Desktop/europ_agriculture_GHG.csv", header = TRUE, sep = ",")
```

```{r, eval=FALSE}
# open the dataset in R
View(ghg)
```


This is a dataset of greenhouse emission from agricultural area of European countries during Year $1990$-$2006$. The original dataset was downloaded from the [European Union Open Data Portal](https://data.europa.eu/euodp/en/data/dataset?q=air+emission&vocab_catalog=http%3A%2F%2Fdata.europa.eu%2F88u%2Fcatalog%2Feuodp&ext_boolean=all&sort=). I simplified the data so that it fits our workshop better.

<br>

Let's take a quick look at the data:

```{r}
# return the first parts of the object which is dataframe "ghg" here
head(ghg)

# return the last parts
tail(ghg)

# return the number of rows
nrow(ghg)

# return the number of columns
ncol(ghg)

# return the dimensions
dim(ghg)
```



>Notice that the datasets you work with in practical may not be clean, for example, there maybe missing values. [Here](https://uc-r.github.io/missing_values) is a link that talks about how to deal with missing values in R. You may find more solutions or suggestions online. 

<br>

**3. Accessing elements in a dataframe**

You can get a specific column of a dataframe by df_name$colume_name`:
```{r, eval=FALSE}
ghg$Country
```


Accessing elements with `df_name[r_index, c_index]`
  
  - `r_index`/`c_index` can be row/column numbers or ranges. For example, get the element at row 3, column 6:
  
```{r}
ghg[3, 6]
```

If you want to get specific row(s), then specify the row number(s) and leave the column part empty, `df_name[r_index, ]`. For example, you can get the first three rows by:
```{r, eval=FALSE}
# return the first 3 rows
ghg[1:3, ]
```


If you just want to select specific column(s), then leave the row index empty, `df_name[ , c_index]`. Here you can get the last 5 columns by:
```{r, eval=FALSE}
# return the last 5 columns
head(ghg[ , 4:8])
```

  - `c_index` can be column names.
  
```{r, eval=FALSE}
ghg[ , c("Country", "Year")]
```
    
  - `r_index` can be relational operator 
  
We can get the records that are after Year $2000$:

```{r, eval=FALSE}
ghg[ghg$Year > 2000, ]
```

Or we may only be interested in "CO2" pollutant, so get the rows of only CO2 by:

```{r, eval=FALSE}
ghg[ghg$Pollutant == "CO2", ]
```

The symbol `>` and `==` we used above are so called "relational operator". Normally a relational operator will return a logical type (TRUE / FALSE) based on the relationship between its leftside and rightside. Then the outer part of the code, if there's any, will decide what to do based on the logical type.

----

>Relational operator:   

- `==`: checks if the left side values equal to that of the right side. So in the example above, for each row, if its `Pollutant` value is "CO2", the row will be filtered as one of the output. 
- `>`: greater than 
- `<`:less than
- `<=`: less than or equal to
- `>=`: greater than or equal to
- `!=`: unequal to 

----


What about if I am interested with the data of both CO2 and after Year 2000?

You can include both two conditions with `&` (**AND**):

```{r, eval=FALSE}
ghg[ghg$Year > 2000 & ghg$Pollutant == "CO2", ]
```


The `|` (**OR**) operator returns true if its leftside or rightside is true. For example, we can get all the rows of pollutant as "CO2" or "CH4" by:

```{r, eval=FALSE}
ghg[ghg$Pollutant == "CO2" | ghg$Pollutant == "CH4", ]
```

The `&` and `|` we just saw are two logical operators.

----

>Logical operator:   

- `!x`: NOT x
- `x | y`: x OR y
- `x & y`: x AND y

----

  
<div class = "Tip3">

**NOTE**

R's basic subsetting operators are powerful. It allows you to adopt different methods, such as relational and logical operators to extract the useful information. I am including some good online resources here about subsetting: [Everything I know about R subsetting](https://hughjonesd.github.io/subsetting.html), and [subsetting in the book *Advanced R*](https://adv-r.hadley.nz/subsetting.html).

</div>



<br>

### <font color="darkgoldenrod">Exercise</font>

- Sort the "Value" column of `ghg` dataframe


<br>


## <font color="darkgoldenrod">Data wrangling with `tidyverse`</font> 

<br>

In the last Exercise, you applied one function `sort` to a dataframe. Sometimes, you may need to use multiple functions, say 10, to a dataframe before you get the final set that you like. Through this long process, you either store the output of each function to a variable and use it as an input of the next function, or use some function commands with data as the argument of the next function. Either way, it can be messy and easy to lose control of.    

In `dplyr` package, there is a pipe operator `%>%`, which allows you to transfer the data or output of the previous function to be as the argument of the next function:

```{r, eval=FALSE}
df_name %>% 
  function1(other arguments)  %>% 
  function2(other arguments) %>% 
  function3(other arguments)
```


We will learn about how to use some basic functions in `dplyr` from now on.

----

### <font color="green">**Select** columns of interest</font> 

Again with the `ghg` data:
```{r}
head(ghg)
```

We can know from the data description that all these data are from agriculture area, so the `Sector` and `Sector_code` columns are not really useful here. Also, we've already known that the `Units` for all the pollutant have all been unified to the same equivalance of $CO_2$, so "Units" column doesn't help explaining any specific information. I am not interested in "Country_code" column neither. So the columns that I am really interested are `Country`, `Pollutant`, `Year`, `Value`. 

To select these columns:
```{r, eval=FALSE}
select(ghg, Country, Pollutant, Year, Value)

ghg %>% 
  select(Country, Pollutant, Year, Value) 
```


We can achieve the same goal by unselect the columns of not interested:

```{r, eval=FALSE}
ghg %>% 
  select(-c(Country_code, Sector, Sector_code, Units))
```


>[More](https://suzan.rbind.io/2018/01/dplyr-tutorial-1/#selecting-columns-the-basics) options for selecting columns.

<br>


### <font color="blue">**Filter** rows of interest</font> 

We may be interested in rows with specific patterns. For example, all the rows with `Pollutant == CO2`:

```{r, eval=FALSE}
ghg %>% 
  select(Country, Pollutant, Year, Value) %>% 
  filter(Pollutant == "CO2")
```



You can filter out rows with `Year > 2000` by:
```{r, eval=FALSE}
ghg %>% 
  select(Country, Pollutant, Year, Value) %>% 
  filter(Year > 2000)
```

In many situations, we may need to filter out rows with multiple conditions. For example, I can filter all the rows with `Year > 2000` and Pollutant == "CO2" by combining these two conditions with `&`:
```{r, eval=FALSE}
ghg %>% 
  select(Country, Pollutant, Year, Value) %>% 
  filter(Year > 2000 & Pollutant == "CO2")
```


<br>

#### <font color="blue">Exercise</font>

- You will use `ghg` as your input data, and use the `%>%` to pipe through functions like what we just did. So,

  - Take `ghg` data, select columns `Country`, `Pollutant`, `Year`, `Value` with `select` function
  - Filter out rows with `Pollutant == N2O`
  - Assign the values generated from above to variable `N2O_ghg` (Hint: use `<-` to assign value to variable)

Solution: 

```{r}
N2O_ghg <- ghg %>% 
  select(Country, Pollutant, Year, Value) %>% 
  filter(Pollutant == "N2O")
```


<br>

### <font color="indigo">Summarize</font> 

```{r}
N2O_ghg %>% 
  count(Year, sort = TRUE)

N2O_ghg %>% 
  summarise(n=n(), average = mean(Value), maximum = max(Value))

N2O_ghg %>% 
  filter(Value > 202323)

N2O_ghg %>% 
  group_by(Country) %>% 
  summarise(average = mean(Value), maximum = max(Value))
```


#### <font color="indigo">Exercise</font>
asdf


<br>

### <font color="violet">mutate?</font> 
asdf

#### <font color="violet">Exercise</font>
asdf

<br>


## Bonus: visualizing data with `ggplot2`
asdf

- syntax of ggplot2

- heatmap of N2O for each country in each year

```{r}
library(ggplot2)

N2O_ghg %>% 
  ggplot(aes(x = Country, y = Year)) +
  geom_tile(aes(fill = Value))
```



### Exercise
asdf

<br>




